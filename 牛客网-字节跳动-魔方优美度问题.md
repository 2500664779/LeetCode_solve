二阶魔方又叫小魔方，是2*2*2的立方形结构。每一面都有4个块，共有24个块。每次操作可以将任意一面逆时针或者顺时针旋转90°，如将上面逆时针旋转90°操作如下。  
![](pictures/魔方优美度1.png)  
Nero在小魔方上做了一些改动，用数字替换每个块上面的颜色，称之为数字魔方。魔方上每一面的优美度就是这个面上4个数字的乘积，而魔方的总优美度就是6个面优美度总和。
现在Nero有一个数字魔方，他想知道这个魔方在操作不超过5次的前提下能达到的最大优美度是多少。
魔方展开后每一块的序号如下图：
![](pictures/魔方优美度2.png)  
<B>输出描述：</b>
> 输出一行包含一个数字，表示最大优美度。  

<B>输入例子1：</b>
> 2 -3 -2 3 7 -6 -6 -7 9 -5 -9 -3 -2 1 4 -9 -1 -10 -5 -5 -10 -4 8 2

<B>输出例子1：</b>
> 8281

#### 解题思路：
可以采用搜索算法，bfs和dfs都可以，甚至递归。

细节方面：
>* 魔方总共有六个面，也就是说，六个面都可以顺时针逆时针转动，但是相对的面如果一个顺时针一个逆时针，则模仿的优美度是一样的。也就是说，需要考虑一次转动对于优美度的改变有六种可能。
>* 转动的时候，以1,3这一列为例，1，7,17,21的位置是对应着的，也就是说当这一列转动的时候，这四个位置是前后进行交替的。可以设计一个函数进行四个位置交替。
>* 还有就是建立二维数组map[6][24]进行转动的映射，然后建立二维数组fae[6][4]，进行面优美度的计算，可以使代码更加简洁。

上一点主要是看到csdn上大佬的解题代码受到的启发，然后他的dfs搜索过程如下  

    void dfs(int dep, vector<int> arr)
    {
        ans = max(ans, getSum(arr));
        if (dep == 5) {
            return ;
        }
        for (int i = 0; i < 6; i++) {
            vector<int> a(arr);
            flip(a, i);
            dfs(dep + 1, a);
            flip(a, i);
            flip(a, i);
            dfs(dep + 1, a);
        }
    }
    ————————————————
    版权声明：本文为CSDN博主「FlushHip」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
    原文链接：https://blog.csdn.net/flushhip/article/details/78267949  
> &emsp;&emsp;这里的循环中，用了三次flip也就是对第i种的转动方式进行了三次，那么逻辑上就是第i种转动方式的一次反转（补充一下，六中翻转中，可以分成三对翻转 ***（上面对下面，左面对右面，前面对后面）*** ，对于同一个初始状态，每一对翻转中的一种和另一个翻转的逆翻转魔方上数字的相对位置是相同的）  
&emsp;&emsp;所以针对上面第i种翻转的三次flip，实际上就是达到了第i种翻转的逆翻转效果，那么实际上只需要和i同一对的翻转执行一次即可，这种情况已经被这个循环包在内部了。  
&emsp;&emsp;当把后两种翻转注释之后进行测试，依旧通过了所有用例。