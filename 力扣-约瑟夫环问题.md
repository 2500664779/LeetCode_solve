### 约瑟夫环问题：
**描述：n个人围成一个圈，任意指定一个数字m(m>=1),轮流进行报数，当数到m时，该人淘汰，下一个从从1继续开始报数，直到剩下最后一个人为止，请问这个人在原来的队列中的序号**  
**思路:** 当n个人中，第m个人被淘汰时，将下一个人的序号重新规定为1，就变成了n-1个人的约瑟夫环问题，可以用到递归。n个人时的胜者就是淘汰一个人之后剩下n-1个人之后的胜者，建立一个变化了之后的序号的对应，**seq(n) =(seq(n-1)+m)%n** ,递归的结束条件为，seq(1) = 0（假设人的编号从0开始到n-1）  
很简单可以建立一个递归函数

    int circle(int n, int m){
        if(n == 1) return 0;
        return (circle(n - 1, m) + m)%n;
    }
递归会带来一个问题就是，如果递归次数过大，会占用过多的栈空间，导致内存不够的问题。
所以可以进行改进：  

    for (int i = 2; i <= n; ++i){
            seq = (seq + m) % i;
        }
最后返回的值是0 - n-1，如果序号从1开始，则需要加1