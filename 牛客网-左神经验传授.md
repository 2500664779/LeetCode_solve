### 首先说一下感想：左神太强了吧，另外创造这些新算法的人也都太强了吧，膜拜真的。顺带提一嘴看左神课程录像的直观感受，上课的这些同学，好像都基础不是太好，有时候需要转一段时间才能够转过来。1.5倍速刷左神的课程实在是太舒服了，强推一下。
#### 1. **KMP算法**
> 是一种加速了的字符串比对的算法，利用了上一次比对的信息。传统的暴力算法的时间复杂度是O(n^2)是因为每次的比对都是独立的，相互之间没有关系&emsp;&emsp;&emsp;
> &emsp;&emsp;建立了一个最**长前后缀匹配**的概念，什么叫前缀和后缀呢？比如说"abc123abcdefgh"，d字符前的子串"abc123abc"，它的前缀就是不包含最后一个字符的从第一个字符开始的子串，例如"123a","123ab"都是前缀，空缀也是前缀的一种，后缀的话则是从尾字符开始不包含头字符的一个子串。
> &emsp;&emsp;在上面的例子中，的最长前后缀匹配数就是3，因为前边的abc和后边的abc匹配。那么这时候如果查找的str2（字符串2）假设是"abc123abcff"，当我们所有位的最长前后缀匹配信息建立之后（假设存在数组next中），匹配到第十个字符的时候，发现了错误，那么这时候就可以利用上述信息数组中存的信息，也就是3来表示，把str2的第一个a和str1中的第二个a对齐继续开始比对，而且这对其的abc我们是不用再次进行检验的。因为计算最长前后缀匹配的信息过程中已经存下来了。

&emsp;&emsp;**那么关键来了**：
&emsp;&emsp;**具体处理流程代码：**
```C++
int * generateNext(const char * array, int length){
    int *Next = new int[length]();
    Next[0] = -1;
    int k = -1, i = 1;
    while(i < length){//注意数组下标是从零开始的
        if(k == -1 || array[i] == array[k]){
            Next[i++] = ++k;
        }
        else{
            k = Next[k];
        }
    }
    return Next;
}
```
这里的k = Next[k]可以说是代码的精髓了，如果能够把这个理解了，那么就应该没问题了。
**题型的其他应用：** 判断一棵树是不是另一棵树的子结构，好像牛客网上的一题就是这个，先把一棵树用字符串的方法唯一的表示出来，方式就是在空的左右子树用#或者其他能够区别开来的标识进行替代，然后前序输出成字符串，接着把另一棵树做相同处理变成另一个字符串，判断后一个字符串是否是前一个字符串的子串即可。

#### 2. **马拉车算法**
经典问题：***最长回文子串***
&emsp;&emsp;首先这题还是存在暴力算法，在字符串的每一个位置上往两边扩展，如果回文子串比当前最大值还大，则更新当前最大值。
> 1. 暴力算法中的细节：奇数个字符的回文子串，从一个字符开始往两边扩展，但是偶数个字符的回文子串需要从两个字符进行扩展。
> 2. 还是由于上一次查找的信息没有存下来，这里依旧是一个空间换时间的方法。

算法**建立的概念：**
> 1. 回文半径数组，是一个额外信息的数组，每个位置都存了当前位置字符前的最长回文的半径。
> 2. 回文右边界，子串回文中达到的最右边界R
> 3. 回文右边界的中心C

在进行算法之前为了解决偶数串和奇数串的问题，往原始字符串中每隔一位加入一个分界符，例如@#$等，举个例子，原始计算字符串"abdefg"添加分界符之后变成"#a#b#c#d#e#f#g#,这样取最大的回文字符串个数/2即可。
一切准备就绪，就开始了。
> 这里我们**假设之前的各种信息都正确，位置已经走到了下标为i的字符**分为两大种情况：
> **1.** i下标字符在回文右边界之外，这时候已经存下来的信息没有用处，需要暴力往外扩，这时候会把回文右边界往右扩，同时需要更新回文右边界的中心。
> **2.** i下标字符在回文右边界之内，这时候需要查看i关于回文右边界中心C的对称点i'，
>> **2.1**如果i'对应的回文左边界在C对应的回文左边界内，根据推理可得i下标的最长回文数就是i'下标的最长回文数
>> **2.2**如果i'对应的回文左边界在C对应的回文左边界外，则根据推理可得i的最长回文半径为i本身到R
>> **2.3**如果i'对应的回文左边界在C对应的回文左边界上，即两个边界刚好相等，这时候在原来的基础上往外扩即可

> 返回的最大值/2即可得原先的字符串最大回文数组。
##### 对应例题
*给定一个字符串，在其末尾添加字符使其变为回文字符串，求需要添加的最少字符个数。* 
这题关键就是找包含了最后一个字符的最长回文序列，也就是当扩展字符串的R第一次达到最右边时，此时C下标对应的最长回文子串，由于是扩展字符串的长度，换算成原本字符串的回文长度需要/2，则还需要添加的最少字符即为原字符串的长度-包含末尾的最长回文子串的长度。
#### 3. **双端队列解决窗口中最值问题**
*这里先规定一下窗口的运动规律：窗口的左右边界都只能往右走，并且左边界不能大于右边界（可以等于，此时窗口中即为一个数）*
> 经典问题：***假设有一个数组array，有一个窗口从左往右滑动，请计算窗口滑动时候窗口内部的最大值。***

暴力解法依旧是O(n^2)的时间复杂度，因为对于每一个窗口都需要把窗口内的数遍历一遍，这里采用双端队列的方法进行存储每一步的信息。
* 双端队列的特性，两边都可以出队入队。

**流程：** (以最大值为例)
* 当窗口的右边界移动时，查看新加进来的数字是否不小于队尾元素，如果是，则从队尾弹出元素，继续比较，直到队空或者队尾元素大于新加进来的数字为止，此时再将新元素入队。
* 当窗口的左边界移动时候，如果新退出窗口的元素不等于队首元素的话则不进行任何操作，否则把队首元素弹出。

**任何时刻队首元素都是滑动窗口中的最大值**
* 第一个操作中为什么要弹出：*首先进队列的肯定比后进队列的更加靠近左边界，因此当之后有更大的数进入窗口时，先前比新进入的数还小的数就不可能再成为窗口中的最大值了，因此弹出。(也可以理解成为：存在于队列中的就是当前窗口的最大值或者将来能够成为最大值的)
* 第二个操作中，很显然新出窗口的数如果不是当前窗口最大值（队首元素）的话，则当前最大值依旧在窗口内，而且新出窗口的数必不是当前窗口最大值，所以出队也没关系

#### 4. **单调栈的应用**
> 解决左右两边离自己最近的比自己大或者比自己小的问题，关键看栈是从底往上递减还是从底往上递增。

#### 5. 荷兰国旗问题
其本质是partition算法变体
**二分partitio算法：**
> 对于一个数组，给定一个数num，把小于等于num的数都放在左边，把大于num的数都放在右边，假设左边界为L，右边界为R，定一个指针i从L遍历到R，再定一个x表示小于等于num的范围，初始为L-1，因为此时还没有开始partition，当i指针往右移动时，只要该数字小于等于num，则swap(array[++x],array[i++]);

**荷兰国旗问题**
> 跟上面的二分partition算法不同，要求小于num的数放在左边，大于num的数放在中间
> 同上，定义less = L - 1，more = R + 1，i下标从L开始，
* 如果array[i] == num，i++，
* 如果array[i] < num,swap(array[++less],array[i++]);
* 如果array[i] > num,swap(array[--more],array[i]),查看此时array[i]跟num的大小，如果等于sum，则++i，如果大于sum，继续swap(array[--more],array[i])，继续查看arra[i];
* 如果i和more撞上了则停止。
#### 6. 二叉树的非递归遍历
> 1. 非递归前序遍历preOrder(Node * root)
>> * 利用一个节点类型的栈，当根节点不空时，先入栈。(可以优化成为节点指针类型的栈，指针就代表了这个节点)
>> * 当栈不空时，执行以下操作：
>> 弹出一个节点，打印当前节点(此处对节点的操作定义为打印),从右到左把子树压入栈。
> 2. 非递归中序遍历inOrder(Node * root)
>> * 同样利用一个节点类型的栈，或者节点指针类型的栈，将root赋值给head
>> * 当 **head不为空**并且**栈不空**的时候执行以下操作
>> 如果head不空，表明当前指向一个节点，压入head，head=head->left;
>> 如果head为空，（也就意味着栈不空，这说明某棵子树的左边已经全部压入栈中）这时候弹出一个节点赋值给head，打印节点并head=head->right回到循环的头部
> 3. 非递归后序遍历postOrder(Node * root)
>> * 利用两个栈，先利用一个栈进行前序遍历的镜像操作即：**前序的顺序是 根->右->左**，然后遍历的时候不要直接对弹出的节点进行打印，而是将它存入多使用的这个栈中，而达到把**根->右->左**的顺序逆序为**左->右->根**

#### 6.5 二叉树的moris遍历
&emsp;&emsp;普通的递归遍历或者非递归遍历的额外空间复杂度都是至少O(N)，其中N是树的结点个数，而moris遍历能够达到额外空间复杂度O(1)的程度。
&emsp;&emsp;主要是利用了二叉树本身的信息，例如叶子节点的空孩子指针。我们规定，
>* 当到达一个节点时，若该左子树的最右边界的next不是指向自己，则将其置为指向自己，然后节点往左划即node = node.left
>* 若该左子树的最右边界是指向自己，则将其置为空，然后node = node.right
>* 若没有左子树，则直接node = node.right



#### 7. 二叉树的序列化和反序列化
&emsp;&emsp;将树结构变化成为字符串保存到文件中，而将树结构的文件重建成为树就称为反序列化（树本身是存在于内存中的，关机之后即被销毁）
这里倒是利用了递归的方式进行序列化，同样序列化也可以采用前序后序和中序三种，以前序为例表明序列化流程：
> 采用一个返回string的递归函数，传入参数为节点的指针，函数形如：**string seqPreOrder(treeNode * root)
> * 递归返回条件：如果root为空则返回空子树占位符和节点间分隔符，只要能和节点value区分开即可。例如“空”采用占位符#，节点间分隔符采用"\_"，则空树返回"#\_",否则返回返回当前节点value值的字符串形式和左右子树的返回字符串之和，左右子树的返回字符串则通过递归调用当前函数进行获得。

**反序列化：**
> * 先把原字符串按照分隔符进行分割然后压入队列，然后调用构建树函数进行构建，返回一个指针指向头结点，把全局的队列作为引用传入
> * 然后把该不断从队列里弹出字符串，如果字符串等于"#",则直接返回NULL;否则就把字符串转化成节点值的类型新建一个节点，左子树的值等于继续调用该函数返回的值，右子树的值等于继续调用该函数返回的值。

***平衡二叉树的概念复习：左右子树都是平衡二叉树，并且左右子树的高度差不超过1，规定空树是平衡二叉树***
> 判断一棵树是否是平衡二叉树：
> * 采用递归，一个函数传入头结点，递归结束条件：当头结点为空时，返回树的高度0，当头结点非空，调用自身求左子树hl和右子树hr的高度，如果有-1出现则表示左右子树中有非平衡二叉树打破平衡则返回-1，否则继续判断两棵树的高度差，如果高度差大于1，返回-1，否则返回子树中高度较高的值+1；
> * 非递归：

***搜索二叉树的概念复习：左子树都比节点小，右子树都比节点大的树***
> 搜索二叉树的特性：中序遍历是依次升序的，利用非递归的中序遍历然后查看是否升序

***完全二叉树的概念复习：类似于数组直接构成的树***
> 判断一个节点是否是完全二叉树：
> * 利用层序遍历，采用队列辅助结构，当遍历的时候，
当一个节点没左子树有右子树的时候，直接return false，
当一个节点只有左子树或者没有子树的时候，之后遍历到的节点必须都是叶节点

**如何求一颗完全二叉树的节点个数，并且复杂度小于O(N)**
&emsp;显然不能用遍历的方式，只能采用递归划分的方式，需要采用到满二叉树的知识
> **树的高度和满二叉树的节点个数**
> 满二叉树的节点个数等于2^H-1个
> * 先获得整棵树的高度H，然后看根节点右子树的最左边界是否达到了这个边界，是的话则说明左子树是一颗高度为H-1的满二叉树，而右边则是另一颗完全二叉树又可以调用一次自身函数。

#### 8 字符串的前缀树trie树？
首先同样是一个树的结构，例如"abc"字符串，给定一个前缀树的空节点（或者叫头结点），然后这时候没有名字为'a'的路，新建一条道路'a'，到达一个新节点，然后从这个节点继续出发，找有没有一个名为'b'的树，如果没有则新建一条道路'b'，接着往下走，依次类推，直到走到数组最后为止。这个结构可以用来查找是否加入某个字符串，字符串的最长前缀是什么。**添加一些数据项例如path和end值，分别表示经过这个点的次数和最终到达这个点的次数，能够查询某个字符串插入了几次，以某个字符串为前缀的词有几个（包含它自身）**

#### 9 贪心策略
&emsp;&emsp;证明过程不用纠结，采用对数器进行对算法的验证
&emsp;**贪心算法常用的场合：图的最小生成树、所有字符串拼接（本质上可以归纳成为最小生成树）**_贪心的本质：设定一个优先级，把所有的对象都按照优先级排序然后进行执行_
1. ***例题***：_题目给了很多字符串，需要把它们全部拼接起来，需要拼接起来之后的长字符串字典序最小_
> 其本质是一个排序问题，按照一定的规则排序就可以获得字典序最小的长字符串，**排序规则**：两个字符串str1和str2，如果str1+str2的字典序小于str2+str1的字典序，则str1排在str2之前。**排序规则需要满足传递性**_例如按照上述规则，假设str1\<str2，str2\<str3,则str1按照上述规则也需要满足\<str3

2. ***例题：*** _切割金条，一条金条切成两半，需要花费和金条长度相同的硬币，现给你一个数组，数组的个数代表一条金条需要分成几块，每个数的大小代表每一块的大小，请求出一整块金条分给成给定结果花费最少的硬币_
&emsp;&emsp;这是经典的哈夫曼编码问题，借助最小堆的结构可以很容易地解决。先将原来数组构建小根堆，当堆大小≥2时，不断取出两个，然后相加把结果丢进去，到最后剩下的一个数即为最小代价。

&emsp;&emsp;***根据不同的比较重载，可以实现不同的堆***

    题目描述：
    假设 LeetCode 即将开始其 IPO。为了以更高的价格将股票卖给风险投资公司，LeetCode希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k个不同的项目。帮助 LeetCode 设计完成最多 k 个不同项目后得到最大总资本的方式。
    给定若干个项目。对于每个项目 i，它都有一个纯利润 Pi，并且需要最小的资本 Ci 来启动相应的项目。最初，你有 W 资本。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。

    总而言之，从给定项目中选择最多 k 个不同项目的列表，以最大化最终资本，并输出最终可获得的最多资本。

    示例 1:

        输入: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].

        输出: 4

    解释:
        由于你的初始资本为 0，你尽可以从 0 号项目开始。
        在完成后，你将获得 1 的利润，你的总资本将变为 1。
        由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。
        因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。
&emsp;**看到这里的时候我都惊了知道吗，3月中，刚好做完字节的笔试，里面有一道题就是沙漠取水问题，简直就是一模一样，只能感叹，没有早一点看到左神的算法课，真是损失了一个亿**
&emsp;根据输入创建项目结构体，包含 **需要的资本**和 **能够收获的利润**两项，然后根据其需要的资本建立一个最小堆，接着不断从堆中弹出**所需资本≤当前所有资本**的项目，将其投入一个最大堆中，然后取出最大堆的堆顶，进行项目的运行之后（就是把该项目利润加入所有资本中），继续抛回最大堆，不断重复上述操作，直到第k步停止或者最大堆里面没有可以操作的项目为止。
&emsp;**沙漠取水问题就是在此基础上做一些修改，例如水站只能进入一次**
3. ***例题***
![会议室安排问题](pictures/会议室安排问题.jpg)
&emsp;*还是一个贪心算法的问题，但是如何贪则是需要考虑的地方，不能根据宣讲会的长短进行谈心，而是应该选用结束时间最早的进行排序。*
&emsp;&emsp;当一个问题贪能举出反例的时候，就说明这种贪的方法是错误的，应该适当调整，根据对象的特性以及所求问题的特性进行分析规划，这一点还是要好好训练


！！！！！！！！！！**上周的阿里题目，收到这个会议室安排的启发，突然有思路了，左神真的牛皮啊**(但是好像，不太一样，那个是最长，这个是最多，再好好思考思考)
<br></br>

#### 10. 从暴力递归到动态规划
![](pictures/递归到dp.jpg)
***不需要死记硬背，关键是理解，李姐、李洁***
* ***汉诺塔问题***（这里就不解释汉诺塔游戏了）
汉诺塔总共有三个杆子，分别叫做from，to和help三根
主要分解流程如下：（假设当前有N个塔盘）
> 先把from杆子上的N-1个盘移动到help之上，然后第N个移动到to之上，接着把help之上的N-1个移动到to之上即可，**这样一个N塔盘的问题就转化成为了N-1个塔盘从help杆子移动到to杆子的问题（因为最大的盘已经放在了最底下所以这时候不会产生任何影响）**则N-1个塔盘的from为原来的help，to仍然为原来的to，而help就是原来的from。递归流程如下：
![](pictures/汉诺塔递归.jpg)

***递归主要的过程就是把问题的规模给减少，然后规定一个基础的问题规模，只要没达到基础规模就把问题继续划分为更少规模的问题抛给自身递归函数进行解决。*** **还有一个就是需要能够把问题抽象出来**

* **母牛生小牛问题：**
描述：
> 给定一只母牛，每年能够生一只母牛，生下的母牛三年后会成熟也会每年生一只母牛，求问N年后一共有多少只母牛？
>> n年时母牛的数量等于n-1年时母牛的数量+n-3年前母牛生下来的小牛的数量

**递归改动态规划适用的类型：** 有许多的重复计算，并且改点的值，跟之后的路径关系是无关的 ***例如矩阵中左上角到达右下角的最短路径之和（经过的数值之和）*** ：在(1, 1)下标的点，无论是如何到达该点的，都不会影响这点到终点的最短路径。
> 以上题为例，做出动态规划的具体步骤：
>* 确定要 求得结果的的最后位置*这里也就是（0,0）点到终点的最短路径*，那么从哪里开始进行规划呢，也就是不依赖任何其他状况的点，这里也就是终点的值是始终不变的，然后根据已知的情况往上一步进行规划，也就是终点上方和终点左方到终点的最短路径。然后继续规划，但是这么搞有点乱，可以先把最后一行和最后一列的最短路径直接求出来（因为在最后行或者最后列的时候行走方式只有一种）**(满足无后效性条件：该步之前的行为不会对该步之后的结果产生影响)**
* **数组求和问题：**
描述：
> 给定一个数组都是正数，给定一个数sum，数组中是否存在若干个数和为sum，若存在返回true，若不存在返回false

*递归版本：* 每到当前位置都做一次决策，要当前位置的数和不要当前位置的数，把这一步的累加和和下一个位置继续传进去递归
```C++
bool isSum(vector<int>& array, int index, int sum, int aim){
    if(index == array.size()) return sum == aim;
    return isSum(array, index + 1, sum, aim) || isSum(array, index + 1, sum + array[index], aim);
    //这里的index == array.size()需要稍微注意下。
}
int main(){
    vecotr<int> array{1,2,5};
    cout << isSum(array, 0, 0, 7);
}
```
这里的可变参数为两个，index和sum两个，因此需要建立二维的dp数组，根据index和sum的变化范围划定数组大小，显然index的变化范围就是0~array.size();这里根据题意，sum可能的变化范围为0~数组中所有整数的和(记做totalSum)，因此建立array.size()*totalSum 的数组，然后我们要求的(即main程序里要输出的最后结果就是0,0位置的)，根据basecase，可以填满index == array.size()这一行，即index == 3这一行如下图
![](pictures/动态规划步骤图1.jpg)
接着根据递归的规则把每一行都填满，得到最后结果：
![](pictures/动态规划步骤图2.jpg)
上图可得最后的结果是0,0位置的true，则最后输出结果应该也是true

### 11. 大楼轮廓问题
&emsp;&emsp;水平面上有 N 座大楼，每座大楼都是矩阵的形状，可以用一个三元组表示 (start, end, height)，分别代表其在x轴上的起点，终点和高度。大楼之间从远处看可能会重叠，求出 N 座大楼的外轮廓线。
&emsp;&emsp;外轮廓线的表示方法为若干三元组，每个三元组包含三个数字 (start, end, height)，代表这段轮廓的起始位置，终止位置和高度。
![](https://lintcode-media.s3.amazonaws.com/problem/jiuzhang3.jpg)
#### 样例
给出三座大楼：
``` C++
[ [1, 3, 3], [2, 4, 4], [5, 6, 1] ]
```
外轮廓线为：
```C++
[ [1, 2, 3], [2, 4, 4], [5, 6, 1] ]
```
#### 解题思路：
> 每一幢大楼都包含了三个信息，**起始坐标、结束坐标和高度**
> 廓线的产生是由于**大楼最高高度**发生改变引起的，那么产生**大楼最高高度**变化的原因就是，
>* 有新的大楼产生，该信息包含在信息的起始坐标中
>* 最高大楼结束，该信息包含在信息的结束坐标中

> 但是无论如何都是和大楼高度结合在一起的，首先将给出的信息，按照 \[ [坐标、高度、是否起始]\] 来切分，题目给出n个大楼信息则可以切分出n*2个信息。将这些信息，按照坐标进行升序排列，然后不断进行遍历

* 然后采用两个辅助**Map**
>* **Map1** *（key，value）对为（高度，该高度出现的次数）* 上述的拆分信息数组排序过后，按照是否起始进行数值的插入：
&emsp;&emsp;如果遍历到的信息是 *[坐标、高度、起始]* 则把其按照高度值插入Map，
&emsp;&emsp;如果遍历到的信息是 *[坐标、高度、非起始]*，则在map中找到对应的key，把它的value-1,如果减为零则把该value抹去
&emsp;&emsp;如果此时Map的最大值发生变化（用一个变量存储，最值发生变化包括从空树到不空，或者从不空到空）则此时将最值和对应的坐标存储进队列。
> * **队列** 不断弹出，当上一个的最高高度为零则不进行轮廓线打印，例如上个弹出的信息为(3,1)下一个信息为(4,2)则说明，从1到2的时候最大高度从3变成了4，则输出廓线(1,2,3).

### 12. 累加和最长子数组
> 给出一个数组array，求其中子数组之和为target的子数组的最长长度。

&emsp;是一道动态规划的问题，分别求出i = 0~size-1为数组最后元素时子数组之和为target的最大长度，然后取最大值即可。
&emsp;若要求某个i下标为数组最后元素的时候子数组之和为target的最大长度，只需要求出，最先出现sum-target累加和的下标即可。从i = 0不断往后退，规定最早出现累加和为零的时候的下标为-1；
> 例如数组【3,2,1,1,6,7】，求累加和为7的最长子数组的长度。

建立（sum，index）的map，并且插入（0，-1），此时子数组最长长度设置为-1；
> * 从i=0开始计算，加到i = 0下标的sum为3，只需要求出从零开始累加和为sum-target = -4最早出现的下标，map中无此记录，则说明i = 0之前的子数组无法加出7，此时出现累加和sum=3，为第一次出现，map中插入（3,0），
>* i = 1时，此时累加和sum = 5，只需要找到累加和为-2第一次出现的下标即可，未找到说明不存在，则说明i=1及之前的子数组无法累加出7，同时第一次出现累加和5，map中插入（5,1）
>* i = 2，sum = 6，找累加和为1第一次出现，找不到，则map插入（6,2）
>* i = 3，sum = 7，找累加和为0第一次出现，为-1，则-1之后到i累加能够成7，更新最大长度为4，map中插入（7,1）
>* i = 4，sum = 13，找累加和为-6第一次出现的位置，没有，则map插入（13,4）
>* i = 5，sum = 20，找累加和为-13第一次出现的位置，没有，则map插入（20,5）
最后返回子数组最长长度4；


#### 12.1 变体
* 在一个数组中，求奇数个数等于偶数个数的最长子数组长度
>* 如果可以修改数组中元素的话，先遍历一遍，把奇数都改成1，偶数都改成-1，那么就转化成为上述求target = 0 的问题。
>* 如果不能修改数组中的元素，则新建一个数组拷贝过来。

### 13 二叉树套路(多叉树也适用)树形DP
> **核心套路：** 从子辈获取信息，当成是黑盒过程，就假定可以得到这个结果，然后根据子辈的信息，结合自身的信息，提取出本身需要传递给父辈的信息进行传递。
**相关问题** ：
> **1.** 一棵树的最大二叉搜索树，
可能性为：
> 1. 最大二叉树在左边，
> 2. 最大二叉树在右边，
> 3. 最大二叉树就是这棵树（左边最大值小于节点值、右边最小值大于节点值，左搜索树头结点为节点左子树，右搜索树头结点为节点右子树，
> **返回信息为：**
> * 该棵树的最大值最小值、该棵树的最大二叉搜索树的大小，最大二叉搜索树的头结点。

> **2.** 树上最远距离，
可能性为：
> 1. 最远距离在左子树
> 2. 最远距离在右子树
> 3. 最远距离为左右子树深度之和加1
> **返回信息为：**
> * 该树的深度、该树的最大距离

> **3.** 员工排队活跃度最大问题（多叉树）
*规则：* 每一个人都是一个节点，公司上下级关系为严格的树形关系，每个人都有其活跃值。当一个人的上级参加派对时，该人肯定不来，而该人上级不参加派对时，来不来取决于你是否给他发邀请函，而你的任务就是保证派对的活跃度最大
&emsp;当处理一个节点时，*如果该节点来，* 则直接下级肯定不来，那么该节点来的时候最大活跃度就是直接下级不来时所有活跃度之和。
*如果该节点不来*则此时该树最大活跃度就是当个下级来或不来活跃度取较大值，然后将所有下级的结果返回。

> **4.** 判断一棵树是否是平衡二叉树
平衡二叉树概念：所有子树的左右子树高度差不超过1； 

**本质就是递归，设定一个basecase，然后将处理过程抽象成黑盒获得子辈的结果，将结果结合本身节点处理成要返回上级的信息返回，需要思考返回数据的结构。**

### 14. 设计可以改变的缓存结构（LRU）（The Least Recently Used）
 **太强了吧 左神，tnd真的牛批脑回路** 
 假设需要存储的东西为struct save，建立一个双向链表和map<value,Node*>，其中链表的尾部表明是最新的最常被使用的
 * 插入一个值：在map建立<value,Node*>记录，然后把结果串到链表的尾部。
 * 查询一个值，如果map中有，则将其挂到尾部，如果其是头，则头往后移动一格（即头指针做相应的调整）
 * 在缓存满的结构下再插入一个新值：首先把头部指针往后移动，然后原头部元素在map中的记录删除，接着把新元素记录插入map，然后节点挂在尾部。

 ### 14.5 设计可以改变的缓存结构（LFU）（Least Frequently Used）
 建立一个大的双向链表，然后将不同使用频率的节点挂在大链表之下，如下图：
 ![](pictures/LFU算法.jpg)
 然后建立两个Map，一个是```<key, Node*>``` 一个是```<Node*, ListNode*>```
 Node就是下面挂着的节点类型，有双向指针，以及对应的```key```，还有```times```即被调用的次数
 上面描黑的节点就是```ListNode*```只包含着双向指针以及指向下挂的第一个Node节点的指针（图中未画出），还有一些需要注意的调整细节：
 >* 当一个ListNode下没有东西之后，这个节点需要被移除，不能空放着（因为```ListNode```中没有存被调用的次数，如果不移除的话，可能随着调用删除次数增大而导致这种空节点越来越多）


 ### 15. 公式字符串返回计算结果问题
 左神不愧是递归小王子，哈哈哈不是白叫的，