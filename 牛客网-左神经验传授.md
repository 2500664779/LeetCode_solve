### 首先说一下感想：左神太强了吧，另外创造这些新算法的人也都太强了吧，膜拜真的。顺带提一嘴看左神课程录像的直观感受，上课的这些同学，好像都基础不是太好，有时候需要转一段时间才能够转过来。1.5倍速刷左神的课程实在是太舒服了，强推一下。
#### 1. **KMP算法**
> 是一种加速了的字符串比对的算法，利用了上一次比对的信息。传统的暴力算法的时间复杂度是O(n^2)是因为每次的比对都是独立的，相互之间没有关系&emsp;&emsp;&emsp;
> &emsp;&emsp;建立了一个最**长前后缀匹配**的概念，什么叫前缀和后缀呢？比如说"abc123abcdefgh"，d字符前的子串"abc123abc"，它的前缀就是不包含最后一个字符的从第一个字符开始的子串，例如"123a","123ab"都是前缀，空缀也是前缀的一种，后缀的话则是从尾字符开始不包含头字符的一个子串。
> &emsp;&emsp;在上面的例子中，的最长前后缀匹配数就是3，因为前边的abc和后边的abc匹配。那么这时候如果查找的str2（字符串2）假设是"abc123abcff"，当我们所有位的最长前后缀匹配信息建立之后（假设存在数组next中），匹配到第十个字符的时候，发现了错误，那么这时候就可以利用上述信息数组中存的信息，也就是3来表示，把str2的第一个a和str1中的第二个a对齐继续开始比对，而且这对其的abc我们是不用再次进行检验的。因为计算最长前后缀匹配的信息过程中已经存下来了。

&emsp;&emsp;**那么关键来了**：
&emsp;&emsp;**具体处理流程代码：**
```C++
int * generateNext(char * array, int length){
    int *Next = new int[length]();
    Next[0] = -1;
    int k = 0, i = 1;
    while(i < length){
        if(k == -1 || array[i] == array[k]){
            Next[i++] = ++k;
        }
        else{
            k = Next[k];
        }
    }
    return Next;
}
```
这里的k = Next[k]可以说是代码的精髓了，如果能够把这个理解了，那么就应该没问题了。
**题型的其他应用：**判断一棵树是不是另一棵树的子结构，好像牛客网上的一题就是这个，先把一棵树用字符串的方法唯一的表示出来，方式就是在空的左右子树用#或者其他能够区别开来的标识进行替代，然后前序输出成字符串，接着把另一棵树做相同处理变成另一个字符串，判断后一个字符串是否是前一个字符串的子串即可。

#### 2. **马拉车算法**
经典问题：***最长回文子串***
&emsp;&emsp;首先这题还是存在暴力算法，在字符串的每一个位置上往两边扩展，如果回文子串比当前最大值还大，则更新当前最大值。
> 1. 暴力算法中的细节：奇数个字符的回文子串，从一个字符开始往两边扩展，但是偶数个字符的回文子串需要从两个字符进行扩展。
> 2. 还是由于上一次查找的信息没有存下来，这里依旧是一个空间换时间的方法。

算法**建立的概念：**
> 1. 回文半径数组，是一个额外信息的数组，每个位置都存了当前位置字符前的最长回文的半径。
> 2. 回文右边界，子串回文中达到的最右边界R
> 3. 回文右边界的中心C

在进行算法之前为了解决偶数串和奇数串的问题，往原始字符串中每隔一位加入一个分界符，例如@#$等，举个例子，原始计算字符串"abdefg"添加分界符之后变成"#a#b#c#d#e#f#g#,这样取最大的回文字符串个数/2即可。
一切准备就绪，就开始了。
> 这里我们**假设之前的各种信息都正确，位置已经走到了下标为i的字符**分为两大种情况：
> **1.** i下标字符在回文右边界之外，这时候已经存下来的信息没有用处，需要暴力往外扩，这时候会把回文右边界往右扩，同时需要更新回文右边界的中心。
> **2.** i下标字符在回文右边界之内，这时候需要查看i关于回文右边界中心C的对称点i'，
>> **2.1**如果i'对应的回文左边界在C对应的回文左边界内，根据推理可得i下标的最长回文数就是i'下标的最长回文数
>> **2.2**如果i'对应的回文左边界在C对应的回文左边界外，则根据推理可得i的最长回文半径为i本身到R
>> **2.3**如果i'对应的回文左边界在C对应的回文左边界上，即两个边界刚好相等，这时候在原来的基础上往外扩即可

> 返回的最大值/2即可得原先的字符串最大回文数组。
##### 对应例题
*给定一个字符串，在其末尾添加字符使其变为回文字符串，求需要添加的最少字符个数。* 
这题关键就是找包含了最后一个字符的最长回文序列，也就是当扩展字符串的R第一次达到最右边时，此时C下标对应的最长回文子串，由于是扩展字符串的长度，换算成原本字符串的回文长度需要/2，则还需要添加的最少字符即为原字符串的长度-包含末尾的最长回文子串的长度。
#### 3. **双端队列解决窗口中最值得问题**
*这里先规定一下窗口的运动规律：窗口的左右边界都只能往右走，并且左边界不能大于右边界（可以等于，此时窗口中即为一个数）*
> 经典问题：***假设有一个数组array，有一个窗口从左往右滑动，请计算窗口滑动时候窗口内部的最大值。***

暴力解法依旧是O(n^2)的时间复杂度，因为对于每一个窗口都需要把窗口内的数遍历一遍，这里采用双端队列的方法进行存储每一步的信息。
* 双端队列的特性，两边都可以出队入队。

**流程：** (以最大值为例)
* 当窗口的右边界移动时，查看新加进来的数字是否不小于队尾元素，如果是，则从队尾弹出元素，继续比较，直到队空或者队尾元素大于新加进来的数字为止，此时再将新元素入队。
* 当窗口的左边界移动时候，如果新退出窗口的元素不等于队首元素的话则不进行任何操作，否则把队首元素弹出。

**任何时刻队首元素都是滑动窗口中的最大值**
第一个操作中为什么要弹出：*首先进队列的肯定比后进队列的更加靠近左边界，因此当之后有更大的数进入窗口时，先前比新进入的数还小的数就不可能再成为窗口中的最大值了，因此弹出。(也可以理解成为：存在于队列中的就是当前窗口的最大值或者将来能够成为最大值的)
第二个操作中，很显然新出窗口的数如果不是当前窗口最大值（队首元素）的话，则当前最大值依旧在窗口内，而且新出窗口的数
