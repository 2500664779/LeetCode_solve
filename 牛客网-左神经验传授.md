### 首先说一下感想：左神太强了吧，另外创造这些新算法的人也都太强了吧，膜拜真的。顺带提一嘴看左神课程录像的直观感受，上课的这些同学，好像都基础不是太好，有时候需要转一段时间才能够转过来。1.5倍速刷左神的课程实在是太舒服了，强推一下。
#### 1. **KMP算法**
> 是一种加速了的字符串比对的算法，利用了上一次比对的信息。传统的暴力算法的时间复杂度是O(n^2)是因为每次的比对都是独立的，相互之间没有关系&emsp;&emsp;&emsp;
> &emsp;&emsp;建立了一个最**长前后缀匹配**的概念，什么叫前缀和后缀呢？比如说"abc123abcdefgh"，d字符前的子串"abc123abc"，它的前缀就是不包含最后一个字符的从第一个字符开始的子串，例如"123a","123ab"都是前缀，空缀也是前缀的一种，后缀的话则是从尾字符开始不包含头字符的一个子串。
> &emsp;&emsp;在上面的例子中，的最长前后缀匹配数就是3，因为前边的abc和后边的abc匹配。那么这时候如果查找的str2（字符串2）假设是"abc123abcff"，当我们所有位的最长前后缀匹配信息建立之后（假设存在数组next中），匹配到第十个字符的时候，发现了错误，那么这时候就可以利用上述信息数组中存的信息，也就是3来表示，把str2的第一个a和str1中的第二个a对齐继续开始比对，而且这对其的abc我们是不用再次进行检验的。因为计算最长前后缀匹配的信息过程中已经存下来了。

&emsp;&emsp;**那么关键来了**：
&emsp;&emsp;**具体处理流程代码：**
```C++
int * generateNext(char * array, int length){
    int *Next = new int[length]();
    Next[0] = -1;
    int k = 0, i = 1;
    while(i < length){
        if(k == -1 || array[i] == array[k]){
            Next[i++] = ++k;
        }
        else{
            k = Next[k];
        }
    }
    return Next;
}
```
这里的k = Next[k]可以说是代码的精髓了，如果能够把这个理解了，那么就应该没问题了。
**题型的其他应用：**判断一棵树是不是另一棵树的子结构，好像牛客网上的一题就是这个，先把一棵树用字符串的方法唯一的表示出来，方式就是在空的左右子树用#或者其他能够区别开来的标识进行替代，然后前序输出成字符串，接着把另一棵树做相同处理变成另一个字符串，判断后一个字符串是否是前一个字符串的子串即可。

#### 2. **马拉车算法**
经典问题：***最长回文子串***
&emsp;&emsp;首先这题还是存在暴力算法，在字符串的每一个位置上往两边扩展，如果回文子串比当前最大值还大，则更新当前最大值。
> 1. 暴力算法中的细节：奇数个字符的回文子串，从一个字符开始往两边扩展，但是偶数个字符的回文子串需要从两个字符进行扩展。
> 2. 还是由于上一次查找的信息没有存下来，这里依旧是一个空间换时间的方法。

算法**建立的概念：**
> 1. 回文半径数组，是一个额外信息的数组，每个位置都存了当前位置字符前的最长回文的半径。
> 2. 回文右边界，子串回文中达到的最右边界R
> 3. 回文右边界的中心C

在进行算法之前为了解决偶数串和奇数串的问题，往原始字符串中每隔一位加入一个分界符，例如@#$等，举个例子，原始计算字符串"abdefg"添加分界符之后变成"#a#b#c#d#e#f#g#,这样取最大的回文字符串个数/2即可。
一切准备就绪，就开始了。
> 这里我们**假设之前的各种信息都正确，位置已经走到了下标为i的字符**分为两大种情况：
> **1.** i下标字符在回文右边界之外，这时候已经存下来的信息没有用处，需要暴力往外扩，这时候会把回文右边界往右扩，同时需要更新回文右边界的中心。
> **2.** i下标字符在回文右边界之内，这时候需要查看i关于回文右边界中心C的对称点i'，
>> **2.1**如果i'对应的回文左边界在C对应的回文左边界内，根据推理可得i下标的最长回文数就是i'下标的最长回文数
>> **2.2**如果i'对应的回文左边界在C对应的回文左边界外，则根据推理可得i的最长回文半径为i本身到R
>> **2.3**如果i'对应的回文左边界在C对应的回文左边界上，即两个边界刚好相等，这时候在原来的基础上往外扩即可

> 返回的最大值/2即可得原先的字符串最大回文数组。
##### 对应例题
*给定一个字符串，在其末尾添加字符使其变为回文字符串，求需要添加的最少字符个数。* 
这题关键就是找包含了最后一个字符的最长回文序列，也就是当扩展字符串的R第一次达到最右边时，此时C下标对应的最长回文子串，由于是扩展字符串的长度，换算成原本字符串的回文长度需要/2，则还需要添加的最少字符即为原字符串的长度-包含末尾的最长回文子串的长度。
#### 3. **双端队列解决窗口中最值问题**
*这里先规定一下窗口的运动规律：窗口的左右边界都只能往右走，并且左边界不能大于右边界（可以等于，此时窗口中即为一个数）*
> 经典问题：***假设有一个数组array，有一个窗口从左往右滑动，请计算窗口滑动时候窗口内部的最大值。***

暴力解法依旧是O(n^2)的时间复杂度，因为对于每一个窗口都需要把窗口内的数遍历一遍，这里采用双端队列的方法进行存储每一步的信息。
* 双端队列的特性，两边都可以出队入队。

**流程：** (以最大值为例)
* 当窗口的右边界移动时，查看新加进来的数字是否不小于队尾元素，如果是，则从队尾弹出元素，继续比较，直到队空或者队尾元素大于新加进来的数字为止，此时再将新元素入队。
* 当窗口的左边界移动时候，如果新退出窗口的元素不等于队首元素的话则不进行任何操作，否则把队首元素弹出。

**任何时刻队首元素都是滑动窗口中的最大值**
* 第一个操作中为什么要弹出：*首先进队列的肯定比后进队列的更加靠近左边界，因此当之后有更大的数进入窗口时，先前比新进入的数还小的数就不可能再成为窗口中的最大值了，因此弹出。(也可以理解成为：存在于队列中的就是当前窗口的最大值或者将来能够成为最大值的)
* 第二个操作中，很显然新出窗口的数如果不是当前窗口最大值（队首元素）的话，则当前最大值依旧在窗口内，而且新出窗口的数必不是当前窗口最大值，所以出队也没关系

#### 4. **单调栈的应用**
> 解决左右两边离自己最近的比自己大或者比自己小的问题，关键看栈是从底往上递减还是从底往上递增。

#### 5. 荷兰国旗问题
其本质是partition算法变体
**二分partitio算法：**
> 对于一个数组，给定一个数num，把小于等于num的数都放在左边，把大于num的数都放在右边，假设左边界为L，右边界为R，定一个指针i从L遍历到R，再定一个x表示小于等于num的范围，初始为L-1，因为此时还没有开始partition，当i指针往右移动时，只要该数字小于等于num，则swap(array[++x],array[i++]);

**荷兰国旗问题**
> 跟上面的二分partition算法不同，要求小于num的数放在左边，大于num的数放在中间
> 同上，定义less = L - 1，more = R + 1，i下标从L开始，
* 如果array[i] == num，i++，
* 如果array[i] < num,swap(array[++less],array[i++]);
* 如果array[i] > num,swap(array[--more],array[i]),查看此时array[i]跟num的大小，如果等于sum，则++i，如果大于sum，继续swap(array[--more],array[i])，继续查看arra[i];
* 如果i和more撞上了则停止。
#### 6. 二叉树的非递归遍历
> 1. 非递归前序遍历preOrder(Node * root)
>> * 利用一个节点类型的栈，当根节点不空时，先入栈。(可以优化成为节点指针类型的栈，指针就代表了这个节点)
>> * 当栈不空时，执行以下操作：
>> 弹出一个节点，打印当前节点(此处对节点的操作定义为打印),从右到左把子树压入栈。
> 2. 非递归中序遍历inOrder(Node * root)
>> * 同样利用一个节点类型的栈，或者节点指针类型的栈，将root赋值给head
>> * 当 **head不为空**并且**栈不空**的时候执行以下操作
>> 如果head不空，表明当前指向一个节点，压入head，head=head->left;
>> 如果head为空，（也就意味着栈不空，这说明某棵子树的左边已经全部压入栈中）这时候弹出一个节点赋值给head，打印节点并head=head->right回到循环的头部
> 3. 非递归后序遍历postOrder(Node * root)
>> * 利用两个栈，先利用一个栈进行前序遍历的镜像操作即：**前序的顺序是 根->右->左**，然后遍历的时候不要直接对弹出的节点进行打印，而是将它存入多使用的这个栈中，而达到把**根->右->左**的顺序逆序为**左->右->根**

#### 6.5 二叉树的moris遍历





#### 7. 二叉树的序列化和反序列化
将树结构变化成为字符串保存到文件中，而将树结构的文件重建成为树就称为反序列化（树本身是存在于内存中的，关机之后即被销毁）
这里倒是利用了递归的方式进行序列化，同样序列化也可以采用前序后序和中序三种，以前序为例表明序列化流程：
> 采用一个返回string的递归函数，传入参数为节点的指针，函数形如：**string seqPreOrder(treeNode * root)
> * 递归返回条件：如果root为空则返回空子树占位符和节点间分隔符，只要能和节点value区分开即可。例如“空”采用占位符#，节点间分隔符采用"\_"，则空树返回"#\_",否则返回返回当前节点value值的字符串形式和左右子树的返回字符串之和，左右子树的返回字符串则通过递归调用当前函数进行获得。

**反序列化：**
> * 先把原字符串按照分隔符进行分割然后压入队列，然后调用构建树函数进行构建，返回一个指针指向头结点，把全局的队列作为引用传入
> * 然后把该不断从队列里弹出字符串，如果字符串等于"#",则直接返回NULL;否则就把字符串转化成节点值的类型新建一个节点，左子树的值等于继续调用该函数返回的值，右子树的值等于继续调用该函数返回的值。

***平衡二叉树的概念复习：左右子树都是平衡二叉树，并且左右子树的高度差不超过1，规定空树是平衡二叉树***
> 判断一棵树是否是平衡二叉树：
> * 采用递归，一个函数传入头结点，递归结束条件：当头结点为空时，返回树的高度0，当头结点非空，调用自身求左子树hl和右子树hr的高度，如果有-1出现则表示左右子树中有非平衡二叉树打破平衡则返回-1，否则继续判断两棵树的高度差，如果高度差大于1，返回-1，否则返回子树中高度较高的值+1；
> * 非递归：

***搜索二叉树的概念复习：左子树都比节点小，右子树都比节点大的树***
> 搜索二叉树的特性：中序遍历是依次升序的，利用非递归的中序遍历然后查看是否升序

***完全二叉树的概念复习：类似于数组直接构成的树***
> 判断一个节点是否是完全二叉树：
> * 利用层序遍历，采用队列辅助结构，当遍历的时候，
当一个节点没左子树有右子树的时候，直接return false，
当一个节点只有左子树或者没有子树的时候，之后遍历到的节点必须都是叶节点

**如何求一颗完全二叉树的节点个数，并且复杂度小于O(N)**
显然不能用遍历的方式，只能采用递归划分的方式，需要采用到满二叉树的知识
> **树的高度和满二叉树的节点个数**
> 满二叉树的节点个数等于2^H-1个
> * 先获得整棵树的高度H，然后看根节点右子树的最左边界是否达到了这个边界，是的话则说明左子树是一颗高度为H-1的满二叉树，而右边则是另一颗完全二叉树又可以调用一次自身函数。

