### 题目描述
机器人正在玩一个古老的基于DOS的游戏。游戏中有N+1座建筑——从0到N编号，从左到右排列。编号为0的建筑高度为0个单位，编号为i的建筑的高度为H(i)个单位。 

起初， 机器人在编号为0的建筑处。每一步，它跳到下一个（右边）建筑。假设机器人在第k个建筑，且它现在的能量值是E, 下一步它将跳到第个k+1建筑。它将会得到或者失去正比于与H(k+1)与E之差的能量。如果 H(k+1) > E 那么机器人就失去 H(k+1) - E 的能量值，否则它将得到 E - H(k+1) 的能量值。

游戏目标是到达第个N建筑，在这个过程中，能量值不能为负数个单位。现在的问题是机器人以多少能量值开始游戏，才可以保证成功完成游戏？
**输入描述:**
>第一行输入，表示一共有 N 组数据.
>第二个是 N 个空格分隔的整数，H1, H2, H3, ..., Hn 代表建筑物的高度

**输出描述:**
> 输出一个单独的数表示完成游戏所需的最少单位的初始能量

**示例1**
输入
>5
>3 4 3 2 4

输出
>4

**示例2**
输入
>3
>4 4 4

**输出**
>4

**示例3**
输入
>3
>1 6 4

**输出**
>3

**备注:**
>数据约束：
1 <= N <= 10^5
1 <= H(i) <= 10^5

> 思路关键是一个恰好的概念，当跳到最后的塔上还剩下1或者0的E，为什么还剩下1呢，因为只要能够跳过来，剩下的能量首先要大于零，根据规则，剩下的能量为2*E(k-1) -H(k),因此，如果H(k)为奇数的话，就有可能剩下的能量为1。所以计算的时候，如果算出上一步能量带有小数，需要向上取整

```C++
#include<iostream>
#include<vector>
#include<math.h>
using namespace std;

int main(){
    int N;
    cin >> N;
    vector<int> H{};
    for (int i = 0; i < N; ++i){
        int temp;
        cin >> temp;
        H.push_back(temp);
    }

    int curE = 0;
    for (int i = N; i >= 0; --i){
        curE = ceil((H[i] + curE) / 2.0);
    }
    cout << curE;
    return 0;
}
```