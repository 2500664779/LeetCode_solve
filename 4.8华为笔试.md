### 1
&emsp;&emsp;**一道快速幂问题(虽然我一开始是不知道快速幂的,用dp过了80的例子,也不知道其他问题出在哪了)**
&emsp;&emsp;**N表示一个位置最多可以由N种表示,L表示最多用L个位置,请问能够表示的编码最多有多少种,例如N = 2,L = 3时,可以有{0,1,00,01,10,11,000,001,010,011,100,101,110,111}总共14种编码,由于结果可能会很大需要对1000000007取余**
给的例子很明朗,就是```N+N^2+……+N^L```的结果,然后对1000000007取余,但是会面临一个问题就是指数太大会溢出.
然后就自己推导了一下取余的运算结论:
> (a+ b) % p = (a % p + b % p) % p &emsp;*(1)*
> (a - b) % p = (a % p - b % p ) % p &emsp;*(2)*
> (a * b) % p = (a % p * b % p) % p &emsp;*(3)*
>
一开始想着用dp进行解答:
```C++
res = (N + N^2+ …… +N^L) % K,             可以转化成:
res = N % K + (N^2) % K + …… + (N^L) % K  又可以转化成:
res = N % K + ((N % K)*N) % K +  …… + (N^(L-1)%K *N) % K
```
这里可以看到后一步的 ```((N^(i-1)) % K * N) % K ```的```(N^(i-1)) % K```就是上一步算出来的结果,可以用dp进行结算
状态转移方程:```dp[i] = (dp[i-1] * N) % K```,然后从dp[1]+……+dp[L],每一步加都对K取余:
```C++
#include<iostream>
#define maxL = 100010;//大于题目中的100000
#define K = 1000000007;
int N;
int L;
long long dp[maxL] = {};
void processDp(){
    dp[0] = 1;
    int i = 0;
    while(++i <= L){
        dp[i] = (dp[i-1] * N) % K;
    }
}
void calRes(){
    int i = 0;
    long long res = 0;
    while(++i <= L){
        res = (res + dp[i]) % K;
    }
    cout << res << '\n';
}

int main(){
    cin >> N >> L;
    while(N && L){
        processDp();
        calRes();
        cin >> N >> L;
    }
    return 0;
}
```
好像我这个方法不属于快速幂啊,用空间换了时间..
>为什么说我这个方法用空间换了时间呢明明是O(L)的时间复杂度呐,有人会说了,快速幂明明是O(LogL)时间复杂度呐,确实,单单计算某一个N^L确实是LogL的时间复杂度,但是由于这里是累加,如果采用等比数列前N项和的公式的话,就产生了除法,无法拆分取余然后再相除,因此也得一个一个计算,时间复杂度达到了O(LlogL).

> **以及为什么要对1000000007进行取余,查了一下资料以及自己的推断,1000000007比int32的一半还稍微小一些,因此它的平方也是小于int64的

### 再来说一下这个快速幂的方法
```要求res = N^L```
分成两种情况:
1. L为偶数,则```res = (N^2)^(L/2)```;
2. L为奇数,则```res = (N^2)^(L/2) * N```;
> 逻辑,只要L能够继续/2不为零,N->N^2,L->L/2,如果L为奇数,res*=N,当然配合取余使用最佳.
那么按照一个逆向思维,写出如下代码:


    #include<iostream>
    using namespace std;
    int N, L, K, result;
    int main(){
        cin >> N >> L >> K;
        result = 1;
        while(L){
            if(L % 2 == 1)
                res = (res * N) % K;
            L /= 2;
            N = (N * N) % K;
        }
        cout << result << '\n';
        return 0;
    }
