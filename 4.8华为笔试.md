### 1
&emsp;&emsp;**一道快速幂问题(虽然我一开始是不知道快速幂的,用dp过了80的例子,也不知道其他问题出在哪了)**
&emsp;&emsp;**N表示一个位置最多可以由N种表示,L表示最多用L个位置,请问能够表示的编码最多有多少种,例如N = 2,L = 3时,可以有{0,1,00,01,10,11,000,001,010,011,100,101,110,111}总共14种编码,由于结果可能会很大需要对1000000007取余**
给的例子很明朗,就是```N+N^2+……+N^L```的结果,然后对1000000007取余,但是会面临一个问题就是指数太大会溢出.
然后就自己推导了一下取余的运算结论:
> (a+ b) % p = (a % p + b % p) % p &emsp;*(1)*
> (a - b) % p = (a % p - b % p ) % p &emsp;*(2)*
> (a * b) % p = (a % p * b % p) % p &emsp;*(3)*
>
一开始想着用dp进行解答:
```C++
res = (N + N^2+ …… +N^L) % K,             可以转化成:
res = N % K + (N^2) % K + …… + (N^L) % K  又可以转化成:
res = N % K + ((N % K)*N) % K +  …… + (N^(L-1)%K *N) % K
```
这里可以看到后一步的 ```((N^(i-1)) % K * N) % K ```的```(N^(i-1)) % K```就是上一步算出来的结果,可以用dp进行结算
状态转移方程:```dp[i] = (dp[i-1] * N) % K```,然后从dp[1]+……+dp[L],每一步加都对K取余:
```C++
#include<iostream>
#define maxL = 100010;//大于题目中的100000
#define K = 1000000007;
int N;
int L;
long long dp[maxL] = {};
void processDp(){
    dp[0] = 1;
    int i = 0;
    while(++i <= L){
        dp[i] = (dp[i-1] * N) % K;
    }
}
void calRes(){
    int i = 0;
    long long res = 0;
    while(++i <= L){
        res = (res + dp[i]) % K;
    }
    cout << res << '\n';
}

int main(){
    cin >> N >> L;
    while(N && L){
        processDp();
        calRes();
        cin >> N >> L;
    }
    return 0;
}
```
好像我这个方法不属于快速幂啊,用空间换了时间..
> **以及为什么要对1000000007进行取余,查了一下资料以及自己的推断,1000000007比int32的一半还稍微小一些,因此它的平方也是小于int64的
