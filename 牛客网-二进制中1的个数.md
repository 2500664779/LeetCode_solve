### 题目描述
输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
> 这里涉及到计算机基础的知识，计算机中带符号整形的存储都用补码来表示，假设计算机用八位来表示补码(短一点比较好举例子，实际上计算机用四个字节存储整形)，
**正数的补码**就是他的二进制原码本身，例如3 = 00000011，最高位为符号位，1代表负数，0代表整数。  
**负数的补码**就是原码除符号位之外全部取反+1，例如-3原码：10000011，除符号位取反+1则为，11111101即为补码，同时也可以看成3的原码00000011全部取反加1.

> **然后根据负数补码的由来，负数-1则结果的补码也相当于在原二进制上-1**这点跟后面的解法很相关。
```C++
class Solution {
public:
     int  NumberOf1(int n) {
         int count{0};
         while(n!=0){
             count++;
             n = n & (n - 1);
         }
         return count;
     }
};
```
> 这里的n&(n-1)就很灵性，先以正数的二进制举例，由于借位的存在，(二进制)n-1会使得n从右往左第一个1变成0,那么假设n为00011100，则n-1为00011011，进行位与运算，则结果为00011000，消除了最右边的一个1，因此，该数二进制中有多少个1就能进行多少次这个运算，直至最终结果为0为止。
> **并且负数补码为100000000时,再减一变为0111111111,即发生了负数溢出,实在是太秀了**
> 接下来说负数，由于是以补码表示，上面已经说到负数-1的结果就相当于补码在原二进制上-1，因此在结果表示上，跟正数没有区别，因此可以用同一套计算方式进行计算。