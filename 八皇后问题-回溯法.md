### 八皇后问题
> 在一个8*8的棋盘上，规定皇后可以攻击到同一行同一列、同一45°斜线和同一135°斜线的其他皇后，现求一摆放方式，使得八皇后无法互相攻击

如果是行列无法互相攻击的话，就是一个全排列问题，把八个皇后编号0-7，每个人占据对应的行号，例如0号皇后规定在0行上，则永远无法产生行之间的冲突，只需要解决列之间的冲突，则是一个八个列八个不同数字的全排列问题。

可以仅此延伸出，将全排列的可能性进行斜线的检查，如果通过检查则满足不攻击原则。
## 但是
全排列问题数目巨大，仅八的阶乘就达到了四万多（没算阶乘之前以为只有几百几千），因此这里采用回溯法比全排列检查合法性更加合理。


```C++
int coun= 1;//调试信息，方便看到是第几个矩阵输出
//行信息，表明下标i表明第i行，值表明是被第几个皇后占据的，实际上好像用不到，一个bool数组就可以了
int Col[8] = {-1, -1, -1, -1, -1, -1, -1, -1};
//列是否被占据，被哪个皇后占据的
int Raw[8] = {-1, -1, -1, -1, -1, -1, -1, -1};
//上对角线是否被占据，被哪个皇后占据的
int d1[15] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
//下对角线是否被占据，被哪个皇后占据的
int d2[15] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};

//打印矩阵，可视化
void PrintChess(){
    for (int i = 0; i < 8; ++i){
        for (int j = 0; j < 8; ++j){
            if(Col[i] != Raw[j]){
                cout.width(2);
                cout << ".";
            }
            else{
                cout.width(2);
                cout << "Q";
            }
        }
        cout << '\n';
    }
    return;
}

//判断第n行，第col个位置是否合法
bool isvalid(int n,int col){   
    return (Col[col] == -1) && (d1[n - col + 7] == -1) && (d2[n + col] == -1);
}

//dfs回溯主函数
void dfs(int n){
    if(n == 8){
        cout << "No." << (coun ++ ) << " times\n";
        PrintChess();
        return;
    }
    
    Raw[n] = n;
    for (int i = 0; i < 8; ++i){
        if(isvalid(n,i)){
            Col[i] = n;
            d1[n - i + 7] = n;
            d2[n + i] = n;
            dfs(n + 1);
            Col[i] = -1;
            d1[n - i + 7] = -1;
            d2[n + i] = -1;
        }
    }
    Raw[n] = -1;
}


int main()  {
    dfs(0);
    getchar();
    getchar();
}
```